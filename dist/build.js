!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).graphicjs=e()}(this,(function(){"use strict";return class{static getMediaDimensions(t){return t instanceof HTMLImageElement?{width:t.naturalWidth,height:t.naturalHeight}:t instanceof HTMLVideoElement?{width:t.videoWidth,height:t.videoHeight}:{width:t.width,height:t.height}}static isMediaLoaded(t){if(!(t instanceof HTMLImageElement||t instanceof HTMLVideoElement))throw new Error("Invalid argument element");return t instanceof HTMLImageElement?t.complete:t.readyState>=HTMLMediaElement.HAVE_FUTURE_DATA}static getInnerDimensions(t){const e=getComputedStyle(t);return{width:t.clientWidth-(parseFloat(e.getPropertyValue("padding-left"))+parseFloat(e.getPropertyValue("padding-right"))),height:t.clientHeight-(parseFloat(e.getPropertyValue("padding-top"))+parseFloat(e.getPropertyValue("padding-bottom")))}}static awaitMediaLoaded(t){return new Promise((e,o)=>{t.addEventListener(t instanceof HTMLVideoElement?"loadedmetadata":"load",t=>e(t),{once:!0}),t.addEventListener("error",t=>o(t),{once:!0})})}static getRotatedRectCoordinates(t,e,o,i,a=0){let n,r,l,s;if(0!==a){const d=t+o/2,h=e+i/2;n=this.getRotationCoordinate(t,e,d,h,a),r=this.getRotationCoordinate(t+o,e,d,h,a),l=this.getRotationCoordinate(t+o,e+i,d,h,a),s=this.getRotationCoordinate(t,e+i,d,h,a)}else n={x:t,y:e},r={x:t+o,y:e},l={x:t+o,y:e+i},s={x:t,y:e+i};return[n,r,l,s]}static getRotationCoordinate(t,e,o,i,a){const n=a*(Math.PI/180),r=Math.sin(n),l=Math.cos(n);return{x:l*(t-o)-r*(e-i)+o,y:r*(t-o)+l*(e-i)+i}}static getCenterCoordinate(...t){const e=t.reduce((t,{x:e,y:o})=>(t.x+=e,t.y+=o,t),{x:0,y:0});return e.x/=t.length,e.y/=t.length,e}static getAngleBetweenCoordinates(t,e,o,i){return 180*Math.atan2(i-e,o-t)/Math.PI}static getDistance(t,e,o,i){return Math.sqrt(Math.pow(o-t,2)+Math.pow(i-e,2))}static fitParent(t,e,o){const{width:i,height:a}=this.getMediaDimensions(t),n=getComputedStyle(t),r=getComputedStyle(e),l=parseFloat(r.getPropertyValue("width"))-parseFloat(r.getPropertyValue("padding-right"))-parseFloat(r.getPropertyValue("border-right-width"))-parseFloat(r.getPropertyValue("padding-left"))-parseFloat(r.getPropertyValue("border-left-width")),s=parseFloat(r.getPropertyValue("height"))-parseFloat(r.getPropertyValue("padding-top"))-parseFloat(r.getPropertyValue("border-top-width"))-parseFloat(r.getPropertyValue("padding-bottom"))-parseFloat(r.getPropertyValue("border-bottom-width")),d=parseFloat(r.getPropertyValue("padding-top"))+parseFloat(r.getPropertyValue("border-top-width"))+parseFloat(r.getPropertyValue("margin-top")),h=parseFloat(r.getPropertyValue("padding-left"))+parseFloat(r.getPropertyValue("border-left-width"))+parseFloat(r.getPropertyValue("margin-left")),g=l/i,c=s/a,p="contain"===o?Math.min(g,c):Math.max(g,c),u=h+(l-i*p)/2,w=d+(s-a*p)/2,y=i*p,f=a*p;"cover"===o&&(e.style.overflow="hidden"),"static"===r.getPropertyValue("position")&&(e.style.position="relative"),"absolute"!==n.getPropertyValue("position")&&(t.style.position="absolute"),t.style.left=u+"px",t.style.top=w+"px",t.style.width=y+"px",t.style.height=f+"px"}static getRenderClientRect(t){const e=getComputedStyle(t).getPropertyValue("object-fit"),o=getComputedStyle(t).getPropertyValue("object-position").split(" "),{width:i,height:a}=this.getMediaDimensions(t),n=i/a,r=t.clientWidth,l=t.clientHeight,s=r/l,d=parseInt(o[0])/100,h=parseInt(o[1])/100;let g=0,c=0,p=0,u=0;const w={width:1,height:1,x:0,y:0};return"none"===e?(g=r,c=l,p=(i-r)*d,u=(a-l)*h):"contain"===e||"scale-down"===e?(g=i,c=a,n>s?(w.height=a/l/(i/r),w.y=(1-w.height)*h):(w.width=i/r/(a/l),w.x=(1-w.width)*d)):"cover"===e?n>s?(g=a*s,c=a,p=(i-g)*d):(g=i,c=i/s,u=(a-c)*h):"fill"===e?(g=i,c=a):console.error(`Unexpected object-fit attribute with value ${e} relative to`),{x:p,y:u,width:g,height:c,destination:w}}static drawPoint(t,e,o,i){i=Object.assign({radius:3,color:"rgb(0,64,221)"},i||{});const a=t.getContext("2d");a.beginPath(),a.arc(e,o,i.radius,0,2*Math.PI),a.fillStyle=i.color,a.fill()}static drawCenterPoint(t,e,o){o=Object.assign({radius:3,color:"rgb(0,64,221)"},o||{});const{x:i,y:a}=this.getCenterCoordinate(...e);this.drawPoint(t,i,a,o)}static drawRectangle(t,e,o,i,a,n){n=Object.assign({degree:0,lineWidth:2,lineColor:"rgb(0,64,221)",shadowBlur:0,shadowColor:"rgb(0,64,221)",fill:void 0},n||{});const r=this.getRotatedRectCoordinates(e,o,i,a,n.degree),l=t.getContext("2d");l.lineWidth=n.lineWidth,l.strokeStyle=n.lineWidth?n.lineColor:"transparent",n.shadowBlur&&(l.shadowOffsetX=0,l.shadowOffsetY=0,l.shadowBlur=n.shadowBlur,l.shadowColor=n.shadowColor),l.beginPath(),l.moveTo(r[0].x,r[0].y),l.lineTo(r[1].x,r[1].y),l.lineTo(r[2].x,r[2].y),l.lineTo(r[3].x,r[3].y),l.closePath(),l.stroke(),n.fill&&(l.fillStyle=n.fill,l.fill())}static drawRectangleCorners(t,e,o,i,a,n){n=Object.assign({lineWidth:2,lineColor:"rgb(0,64,221)",shadowBlur:0,shadowColor:"rgb(0,64,221)"},n||{});const r=t.getContext("2d");n.lineWidth&&(r.strokeStyle=n.lineColor,r.lineWidth=n.lineWidth),n.shadowBlur&&(r.shadowOffsetX=0,r.shadowOffsetY=0,r.shadowBlur=n.shadowBlur,r.shadowColor=n.shadowColor);const l=Math.min(i,a)/4;r.beginPath(),r.moveTo(e,o+l),r.lineTo(e,o),r.lineTo(e+l,o),r.moveTo(e+i-l,o),r.lineTo(e+i,o),r.lineTo(e+i,o+l),r.moveTo(e,o+a-l),r.lineTo(e,o+a),r.lineTo(e+l,o+a),r.moveTo(e+i-l,o+a),r.lineTo(e+i,o+a),r.lineTo(e+i,o+a-l),r.stroke()}static drawText(t,e,o,i,a){a=Object.assign({font:"14px arial,sans-serif",color:"black",align:"left",baseline:"top"},a||{});const n=t.getContext("2d");n.font=a.font,n.fillStyle=a.color,n.textAlign=a.align,n.textBaseline=a.baseline,n.fillText(e,o,i)}static drawLine(t,e,o,i,a,n){n=Object.assign({lineWidth:1,color:"rgb(0,64,221)"},n||{});const r=t.getContext("2d");r.beginPath(),r.moveTo(e,o),r.lineTo(i,a),r.strokeStyle=n.color,r.lineWidth=n.lineWidth,r.stroke()}static clearCanvas(t){t.getContext("2d").clearRect(0,0,t.width,t.height)}static flipHorizontal(t){const e=t.getContext("2d"),o=e.getImageData(0,0,t.width,t.height),i=o.height,a=o.width;for(let t=0;t<i;t++)for(let e=0;e<a/2;e++){const i=4*t*a+4*e,n=4*(t+1)*a-4*(e+1);for(let t=0;t<4;t++){let e=o.data[i+t];o.data[i+t]=o.data[n+t],o.data[n+t]=e}}e.putImageData(o,0,0,0,0,a,i)}static async loadImage(t){const e=new Image;return e.setAttribute("src",t),await this.awaitMediaLoaded(e),e}static async cropCircle(t,e){e=Object.assign({x:void 0,y:void 0,size:void 0,format:"image/png"},e||{}),"string"==typeof t&&(t=await this.loadImage(t)),this.isMediaLoaded(t)||await this.awaitMediaLoaded(t);const{width:o,height:i}=this.getMediaDimensions(t),a=Math.min(o,i);let n=e.x||0,r=e.y||0;!e.x&&o>i&&(n=o/2-i/2),!e.y&&o<i&&(r=i/2-o/2);const l=document.createElement("canvas");l.width=e.size||a,l.height=e.size||a;const s=l.getContext("2d");s.drawImage(t,n,r,a,a,0,0,l.width,l.height),s.globalCompositeOperation="destination-in",s.beginPath(),s.arc(l.width/2,l.height/2,l.width/2,0,2*Math.PI),s.closePath(),s.fill();const d=new Image;return d.src=l.toDataURL(e.format,1),d}}}));
